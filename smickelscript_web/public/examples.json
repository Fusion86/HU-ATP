[["None", ""], ["game_of_life.sc", "# Board size is 16*8 WxH, so 128 tiles in total.\n#\n# Y\n# |\n# |\n# |\n# |\n# |\n# |\n# |\n# | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ X\n#\n# See https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\nstatic var board: array[128];\nstatic var board_next: array[128];\n\nfunc main() {\n    var speed = 1000; # Lower is faster\n    # If you set the speed value to a large value the CLI tool will think the Arduino timed out and exit.\n    # This can be bypassed by using PlatformIO monitor, or by fixing the CLI tool.\n\n    println_str(\"Welcome to Conway's Game of Life\");\n\n    # Change this number here to create other boards.\n    init_board(1);\n\n    var step = 0;\n    while (step < 16) {\n        println_str(\"================\");\n        print_board();\n        simulate_board();\n        delay(speed);\n        step = step + 1;\n    }\n\n    println_str(\"The end.\")\n}\n\n# Init board\n# Types:\n# 0 - Empty board\n# 1 - Block and blinker\n# 2 - Beehive and toad\n# 3 - Light-weight spaceship\nfunc init_board(type: number) {\n    // Set the board to zero\n    // Not really needed on the first run, but doesn't hurt either.\n    var i = 0;\n    while (i < 128) {\n        board[i] = 0;\n        i = i + 1;\n    }\n\n    if (type == 1) {\n        // Block\n        board[51] = 1;\n        board[52] = 1;\n        board[67] = 1;\n        board[68] = 1;\n\n        // Blinker\n        board[41] = 1;\n        board[57] = 1;\n        board[73] = 1;\n        return 0;\n    }\n\n    if (type == 2) {\n        // Beehive\n        board[18] = 1;\n        board[19] = 1;\n        board[33] = 1;\n        board[36] = 1;\n        board[50] = 1;\n        board[51] = 1;\n\n        // Toad\n        board[42] = 1;\n        board[56] = 1;\n        board[59] = 1;\n        board[72] = 1;\n        board[75] = 1;\n        board[89] = 1;\n    }\n\n    if (type == 3) {\n        // Light-weight spaceship\n        board[17] = 1;\n        board[20] = 1;\n        board[37] = 1;\n        board[49] = 1;\n        board[53] = 1;\n        board[66] = 1;\n        board[67] = 1;\n        board[68] = 1;\n        board[69] = 1;\n    }\n}\n\nfunc print_board() {\n    var i = 0;\n    var x = 0;\n    while (i < 128) {\n        var cell = board[i];\n\n        if (cell == 1) {\n            print_str(\"X\");\n        } else {\n            print_str(\" \");\n        }\n\n        i = i + 1;\n\n        # Shitty alternative to the module operator.\n        # Though this is probably more performance friendly than implementing modulo ourselves.\n        x = x + 1;\n        if (x == 16) {\n            x = 0;\n            println_str(\"\");\n        }\n        # P.S. we now have a modulo operator in the language, but we didn't have it when I was writing this part of the code.\n        # Though maybe the performance still is better with this code?\n    }\n}\n\n# Simulate one full 'step' of the game of life.\n# Create new state in the `board_next` array, and write this array to the `board` array when\n# all tiles have been updated.\nfunc simulate_board() {\n    # A live cell dies unless it has exactly 2 or 3 live neighbors.\n    # A dead cell remains dead unless it has exactly 3 live neighbors.\n\n    var i = 0;\n    while (i < 128) {\n        # Figure out if the current cell is dead or alive.\n        var cell = board[i];\n        var alive_neighbor_count = count_live_neighbors(i);\n\n        # If cell is alive\n        if (cell == 1) {\n            if (alive_neighbor_count != 2) {\n                if (alive_neighbor_count != 3) {\n                    cell = 0;\n                }\n            }\n        } else {\n            if (alive_neighbor_count == 3) {\n                cell = 1;\n            }\n        }\n\n        board_next[i] = cell;\n\n        i = i + 1;\n    }\n\n    # Copy values from `board_next` to `board`\n    i = 0;\n    while (i < 128) {\n        var tmp = board_next[i];\n        board[i] = tmp;\n        i = i + 1;\n    }\n}\n\nfunc count_live_neighbors(i: number) {\n    var tmp = 0;\n    var count = 0;\n\n    # Wrapping around is not supported, because it is a PITA to implement.\n    tmp = is_edge(i);\n    if (tmp == 0) {\n        # Return count, aka zero.\n        return count;\n    }\n\n    # Top left\n    tmp = i - 17; # Calculate neigbor index\n    tmp = board[tmp]; # Check if neighbor is alive\n    count = count + tmp; # Count += 1 if neighbor is alive\n\n    # Top middle\n    tmp = i - 16;\n    tmp = board[tmp];\n    count = count + tmp;\n\n    # Top right\n    tmp = i - 15;\n    tmp = board[tmp];\n    count = count + tmp;\n\n    # Middle left\n    tmp = i - 1;\n    tmp = board[tmp];\n    count = count + tmp;\n\n    # Middle right\n    tmp = i + 1;\n    tmp = board[tmp];\n    count = count + tmp;\n\n    # Bottom left\n    tmp = i + 15;\n    tmp = board[tmp];\n    count = count + tmp;\n\n    # Bottom left\n    tmp = i + 16;\n    tmp = board[tmp];\n    count = count + tmp;\n\n    # Bottom left\n    tmp = i + 17;\n    tmp = board[tmp];\n    count = count + tmp;\n\n    return count;\n}\n\nfunc is_edge(n) {\n    # Top row and leftmost item on the second row\n    if (n < 17) { return 1; }\n\n    # Left edge\n    if (n == 32) { return 1; }\n    if (n == 48) { return 1; }\n    if (n == 64) { return 1; }\n    if (n == 80) { return 1; }\n    if (n == 96) { return 1; }\n\n    # Right edge\n    if (n == 31) { return 1; }\n    if (n == 46) { return 1; }\n    if (n == 63) { return 1; }\n    if (n == 79) { return 1; }\n    if (n == 95) { return 1; }\n\n    # Bottom row and rightmost item on the second-last row\n    if (n > 110) { return 1; }\n}\n"], ["hello_world.sc", "func main() {\n    println_str(\"Hello World\");\n}\n"], ["hello_world_indirect.sc", "func main() {\n    println_str(\"Hello from main.\");\n    hello();\n    println_str(\"Hello from main again.\");\n}\n\nfunc hello() {\n    println_str(\"Hello world from hello func.\");\n}\n"], ["how_many_days.sc", "    static var div_a = 0;\n    static var div_b = 0;\n\n    func division(): number {\n        var c: number = 0;\n        div_a = div_a - div_b;\n        while (div_a >= 0) {\n            div_a = div_a - div_b;\n            c = c + 1;\n        }\n        return c;\n    }\n\nfunc main() {\n    // Hardcode func parameters because we can't pass those when compiling for Arduino.\n    static var year = 1998;\n    static var month = 11;\n    static var day = 16;\n\n    // Hardcode the current date, because there is no way to get the current date.\n    static var now_day = 17;\n    static var now_month = 5;\n    static var now_year = 2021;\n\n    static var years_old = 0;\n    years_old = now_year - year;\n\n    static var years_days_old = 0;\n    years_days_old = years_old * 365;\n\n    // Approximate leap years\n    div_a = years_old;\n    div_b = 4;\n    var div = division();\n    years_days_old = years_days_old + div;\n\n    static var months_old = 0;\n    months_old = now_month - month;\n\n    static var months_days_old = 0;\n    months_days_old = months_old * 30;\n\n    // Approximate uneven months\n    div_a = months_old;\n    div_b = 2;\n    div = division();\n    div = div - 2; // Hacky way to account for february\n    months_days_old = months_days_old + div;\n\n    static var days_old = 0;\n    days_old = now_day - day;\n\n    var days: number = 0;\n    days = days + years_days_old;\n    days = days + months_days_old;\n    days = days + days_old;\n\n    print_str(\"You are approximately \");\n    print_integer(days);\n    println_str(\" days old.\");\n}\n"], ["possible_infinite_runtime.sc", "# This doesn't work too well on the actual Arduino because we lack 'randomness'.\n\nfunc main() {\n    var max = 600;\n    var r = 1;\n\n    while (r != 0) {\n        r = rand(max);\n        println_str(\"To infinity!\");\n    }\n}\n"], ["roll_dice.sc", "func main() {\n    var count = 4;\n    while (count > 0) {\n        count = count - 1;\n        print_str(\"Rolled a: \");\n        var res = rand(6);\n        res = res + 1; # +1 because rand returns 0-5\n        println_integer(res);\n    }\n}\n"]]